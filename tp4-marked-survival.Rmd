---
title: "TP 4 marked survival"
author: "Olivier Gimenez"
date: "19/12/2020"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE)
```

On charge les packages `RMark` et `R2ucare`.
```{r}
library(RMark)
library(R2ucare)
```

# Partie 1 : Estimation de la survie, exemple du cincle plongeur

Les données
```{r}
cincle <- convert.inp("dat/cincle-plongeur.inp")
head(cincle)
```

Process the data
```{r}
cincle.proc <- process.data(cincle, 
                              begin.time = 1, 
                              model = "CJS")
```

Create default design data
```{r}
cincle.ddl <- make.design.data(cincle.proc)
```

Examine the design data 
```{r}
head(cincle.ddl$Phi)
head(cincle.ddl$p)
```

On spécifie les effets sur les paramètres.
```{r}
phit <- list(formula=~time)
phi <- list(formula=~1)
pt <- list(formula=~time)
p <- list(formula=~1)
```

Fait tourner modèle CJS.
```{r}
cjs.cincle <- mark(cincle.proc,
                   cincle.ddl,
                   model.parameters = list(Phi = phit, p = pt))
cjs.cincle$results$real
```

PIM pour CJS.
```{r}
PIMS(cjs.cincle,"Phi")
```

Fait tourner modèle avec param constants. 
```{r}
phip.cincle <- mark(cincle.proc,
                    cincle.ddl,
                    model.parameters = list(Phi = phi, p = p))
phip.cincle$results$real
```

PIM pour CJS.
```{r}
PIMS(phip.cincle,"Phi")
PIMS(phip.cincle,"p")
```

On ajoute les covariables environnementales. 
```{r}
cov.cincle <- readxl::read_xls("dat/covariables-environnementales-cincle-plongeur.xls")
cov.cincle
```

On simplifie le nom des colonnes.
```{r}
cov.cincle <- janitor::clean_names(cov.cincle)
cov.cincle
```

On a 7 occasions de capture, donc 6 paramètres de survie. Si on suppose que la première année de capture dans le jeu de données cincle est 1981, alors on peut estimer la survie entre 1981 et 1982, à laquelle on applique la valeur de covariable en 1981, etc... jusqu'à la survie entre 1986 et 1987 à laquelle s'applique la valeur de covariable de 1986, donc on n'a pas besoin de la dernière ligne dans le jeu de données. 
```{r}
cov.cincle <- cov.cincle[!(cov.cincle$annee == "1987"),]
```

On crée une survie qui depend du débit. Jetons un coup d'oeil à la structure sur la survie.
```{r}
cincle.ddl$Phi
```

```{r}
cincle.ddl$Phi$debit <- 0 # nv var mise a 0
for (i in 1:nrow(cov.cincle)){
   cincle.ddl$Phi$debit[cincle.ddl$Phi$time == i] <- as.numeric(cov.cincle[i, "debit_l_sec"]) 
}
```

On vérifie que ça a marché.
```{r}
cincle.ddl$Phi
```

Idem pour temperature.
```{r}
cincle.ddl$Phi$temp <- 0 # nv var mise a 0
for (i in 1:nrow(cov.cincle)){
   cincle.ddl$Phi$temp[cincle.ddl$Phi$time == i] <- as.numeric(cov.cincle[i, "temperature_hiver_c"])
}
cincle.ddl$Phi
```

On définit les effets.
```{r}
phi.debitptemp <- list(formula =~ debit + temp)
```

On ajuste le modèle.
```{r}
phicov.cincle <- mark(cincle.proc,
                      cincle.ddl,
                      model.parameters = list(Phi = phi.debitptemp, p = p))
```

Les paramètres estimés.
```{r}
phicov.cincle$results$real
```

Visualisons relation survie débit pour une valeur moyenne de température.
```{r}
min.debit <- min(cov.cincle$debit_l_sec)
max.debit <- max(cov.cincle$debit_l_sec)
debit.values <- seq(from = min.debit, to = max.debit, by = 5)
temp.values <- c(quantile(cov.cincle$temperature_hiver_c, 0.05), 
                  mean(cov.cincle$temperature_hiver_c),
                  quantile(cov.cincle$temperature_hiver_c, 0.95))
```

Construit le jeu de données. 
```{r}
pred.dat <- expand.grid(debit = debit.values,
                        temp = temp.values)
pred.dat <- cbind(1, pred.dat)
pred.dat <- as.matrix(pred.dat)
```

Make prediction sur échelle logit.
```{r}
betas.phi <- phicov.cincle$results$beta[1:3,1]
pred.surv.logit <- pred.dat %*% betas.phi
```

On back-transforme et on arrange.
```{r}
pred.surv <- plogis(pred.surv.logit)
pred.df <- cbind(pred.dat[,-1], pred.surv)
colnames(pred.df) <- c("debit", "temp", "survie")
pred.df <- as.data.frame(pred.df)
head(pred.df)
```

On prépare les données. 
```{r}
pred.df$temp <- ifelse(pred.df$temp == mean(cov.cincle$temperature_hiver_c),
                           "temp_moyenne",
                           ifelse(pred.df$temp == quantile(cov.cincle$temperature_hiver_c, 0.05), 
                                  "temp_quantile_0.05",
                                  "temp_quantile_0.95"))
head(pred.df)
```

On visualise.
```{r}
library(ggplot2)
ggplot(pred.df, aes(x = debit, y = survie)) +
   geom_line(aes(color = temp), size = 1.5) +
   labs(x = "Débit",
        y = "Survie estimée",
        color = "température") + 
    ylim(0, 1) +
   theme_light()
```


# Partie 2 : Estimation de la survie, exemple du martinet noir

Les données
```{r}
martinet <- convert.inp("dat/martinet-noir.inp",
                        group.df = data.frame(colonie = c("nord", "sud")), 
                        covariates = NULL)
head(martinet)
```

Process the data
```{r}
martinet.proc <- process.data(martinet, 
                              begin.time = 1, 
                              model = "CJS", 
                              groups = ("colonie"))
```

Create default design data
```{r}
martinet.ddl <- make.design.data(martinet.proc)
```

Examine the design data 
```{r}
head(martinet.ddl$Phi)
head(martinet.ddl$p)
```

On spécifie les effets sur les paramètres.
```{r}
phit <- list(formula=~time)
phi <- list(formula=~1)
pt <- list(formula=~time)
p <- list(formula=~1)
```

Fait tourner modèle CJS.
```{r}
cjs.martinet <- mark(martinet.proc,
                      martinet.ddl,
                      model.parameters = list(Phi = phit, p = pt))
cjs.martinet$results$real
```

PIM pour CJS.
```{r}
PIMS(cjs.martinet,"Phi")
```

Fait tourner modèle avec param constants. 
```{r}
phip.martinet <- mark(martinet.proc,
                      martinet.ddl,
                      model.parameters = list(Phi = phi, p = p))
phip.martinet$results$real
```

PIM pour CJS.
```{r}
PIMS(phip.martinet,"Phi")
```

Modèle avec 2 classes d'âge sur la survie.
```{r}
# create 0, 1+ age variable
martinet.ddl <- add.design.data(martinet.proc,
                                martinet.ddl, # add 2 age-class structure to design matrix
                             "Phi",
                             type = "age",
                             bins = c(0, 1, 7),
                             name = "ageclass",
                             right = FALSE)
```

Parameter specification.
```{r}
phi.age <- list(formula=~ageclass) # age effect on survival
```

Fit CJS model.
```{r}
CJSage.martinet <- mark(martinet.proc,
                        martinet.ddl,
                        model.parameters = list(Phi = phi.age, p = p))
CJSage.martinet$results$real
```

PIM pour CJS avec âge.
```{r}
PIMS(CJSage.martinet,"Phi")
```

Maintenant gros modèle ${phi(a.g), p(g.t)}$.

Parameter specification.
```{r}
phi.a.g <- list(formula=~ageclass*colonie) # age and colonie effect on survival
p.g.t <- list(formula=~colonie*time) # age and colonie effect on survival
```

Fit CJS model.
```{r}
gros.mod <- mark(martinet.proc,
                        martinet.ddl,
                        model.parameters = list(Phi = phi.a.g, p = p.g.t))
gros.mod$results$real
```

PIM pour survie et détection dans big model.
```{r}
PIMS(gros.mod,"Phi")
PIMS(gros.mod,"p")
```

# Partie 3 : Hypothèses des modèles de capture-recapture, hétérogénéité et tests d'ajustement

Le but de cet exercice est de se familiariser avec les données de capture-recapture en population ouverte, d’ajuster par maximum de vraisemblance quelques modèles simples, de comparer ces modèles entre eux pour déterminer celui qui fournit la meilleure description des données et de tester la qualité de l’ajustement de ces modèles.

## Question 1

On simule 2 jeux de données de capture-recapture avec les paramètres de survie ($\phi$) et recapture ($p$) suivants :
* jeu de données G1 : $\phi = 0.8$, $p = 0.8$ ;
* jeu de données G2 : $\phi = 0.8$, $p = 0.2$.

```{r}
simul <- function(nind, nocc, phi, p){
   dat <- matrix(0, nrow = nind, ncol = nocc)
   dat[1:nind, 1] <- 1 # a single cohort
   for (i in 1:nind){
      # processus survie
      for (j in 2:nocc){
         alive.or.dead <- rbinom(1, 1, phi)
         # conditional on being alive at t, alive or dead at t+1
         dat[i, j] <- ifelse(dat[i, j - 1] == 0, 0, alive.or.dead) 
      }
      # processus detection
      for (j in 2:nocc){
         detected.or.not <- rbinom(1, 1, p)
         # conditional on being alive at t, detected or not at t
         dat[i, j] <- ifelse(dat[i, j] == 0, 0, detected.or.not) 
      }
   }
data.frame(y = dat)   
}
```


```{r}
set.seed(2021)
nind <- 500
nocc <- 8
G1 <- simul(nind = nind, nocc = nocc, phi = 0.8, p = 0.8)
G2 <- simul(nind = nind, nocc = nocc, phi = 0.8, p = 0.2)
```

A l’aide du package `marked`, ajuster séparément à G1 et G2 le modèle ${\Phi(t), p(t)}$ appelé aussi le modèle de Cormack-Jolly-Seber (CJS). Que pouvez-vous vous dire sur l’estimation des paramètres ?

```{r}
G1marked <- data.frame(ch = tidyr::unite(G1, col = "ch", sep = ""), 
                       n = rep(1, nrow(G1)))
G2marked <- data.frame(ch = tidyr::unite(G2, col = "ch", sep = ""), 
                       n = rep(1, nrow(G2)))
```

Process data
```{r}
G1.proc <- process.data(G1marked)
G2.proc <- process.data(G2marked)
```

Make design data
```{r}
G1.ddl <- make.design.data(G1.proc)
G2.ddl <- make.design.data(G2.proc)
```

Look at design data
```{r}
G1.ddl
```

Outine formulas for each parameter
```{r}
phi <- list(formula=~1)  
p <- list(formula=~1)
```

Make model constant survival and detection prob. For G1 first. 
```{r}
cjs.G1 <- mark(G1.proc,
              G1.ddl,
              model.parameters = list(Phi = phi, p = p))
cjs.G1$results$real
```

Then for G2. 
```{r}
cjs.G2 <- mark(G2.proc,
              G2.ddl,
              model.parameters = list(Phi = phi, p = p))
cjs.G2$results$real
```

## Question 2

a) Grouper les jeux de données G1 et G2 pour obtenir le jeu de données G1+G2.

```{r}
G1plusG2 <- rbind(G1, G2)
```

b) Ajuster le modèle CJS à G1+G2. Que remarquez-vous concernant l’estimation des paramètres ?

```{r}
G1G2marked <- data.frame(ch = tidyr::unite(G1plusG2, col = "ch", sep = ""),
                         n = rep(1, nrow(G1plusG2)))
G1G2.proc <- process.data(G1G2marked)
G1G2.ddl <- make.design.data(G1G2.proc)
cjs.G1G2 <- mark(G1G2.proc,
                G1G2.ddl,
                model.parameters = list(Phi = phi, p = p))
cjs.G1G2$results$real
```

Modèle avec survie qui dépend du temps.
```{r}
phi.time <- list(formula=~time)  
cjs.G1G2 <- mark(G1G2.proc,
                G1G2.ddl,
                model.parameters = list(Phi = phi.time, p = p))
cjs.G1G2$results$real
```

## Question 3

A l’aide du package `R2ucare`, tester la qualité de l’ajustement du modèle CJS aux données G1, G2 et G1+G2. Quelles sont vos conclusions ?

G1
```{r}
overall_CJS(G1, rep(1,nrow(G1)))
```

G2
```{r}
overall_CJS(G2, rep(1,nrow(G2)))
```

G1G2
```{r}
overall_CJS(G1plusG2, rep(1,nrow(G1plusG2)))
```

## Question 4

Il peut y avoir des animaux en transit sur la zone d’étude.

a) Pour créer artificiellement une telle situation, rajouter 50 individus en transit (i.e. possédant une histoire avec un seul événement de capture) à chaque date dans G1. Voir la fin du fichier G1transit.inp

```{r}
G1transit <- as.matrix(G1)
ntransients <- 50
for (j in 1:nocc){
   zeros <- matrix(0, nrow = ntransients, ncol = nocc)
   zeros[, j] <- 1
   G1transit <- rbind(G1transit, zeros)
}
G1transit <- data.frame(y = G1transit)
```

```{r}
dim(G1transit)
head(G1transit)
tail(G1transit)
```


b) faire tourner le modèle CJS à ces nouvelles données avec `RMark`. Quelles sont vos conclusions concernant les estimations ?

```{r}
G1transitmarked <- data.frame(ch = tidyr::unite(G1transit, col = "ch", sep = ""), 
                              n = rep(1, nrow(G1transit)))
```

Process data
```{r}
G1transit.proc <- process.data(G1transitmarked)
```

Make design data
```{r}
G1transit.ddl <- make.design.data(G1transit.proc)
```

Fit CJS model.
```{r}
cjs.G1transit <- mark(G1transit.proc,
                     G1transit.ddl,
                     model.parameters = list(Phi = phi, p = p))
cjs.G1transit$results$real
```

Idem avec survie qui dépend du temps.
```{r}
cjs.G1transit <- mark(G1transit.proc,
                     G1transit.ddl,
                     model.parameters = list(Phi = phi.time, p = p))
cjs.G1transit$results$real
```

c) Tester l’ajustement du modèle CJS à ces mêmes données avec `R2ucare`. Interpréter en particulier la composante 3.SR du test.

```{r}
overall_CJS(G1transit, rep(1,nrow(G1transit)))
test2ct(G1transit, rep(1,nrow(G1transit)))
test3sr(G1transit, rep(1,nrow(G1transit)))
```


d) faire tourner un modèle à 2 classes d’âge sur la survie $\phi(a2*t)$ avec `RMark`. Vos conclusions ?

```{r}
G1transit.ddl <- make.design.data(G1transit.proc)
# create 0, 1+ age variable
G1transit.ddl <- add.design.data(G1transit.proc,
                             G1transit.ddl, # add 2 age-class structure to design matrix
                             "Phi",
                             type = "age",
                             bins = c(0, 1, nocc - 1),
                             name = "ageclass",
                             right = FALSE)
```

Parameter specification.
```{r}
phi.age <- list(formula=~ageclass) # age effect on survival
```

Fit CJS model.
```{r}
cjsage.G1transit <- mark(G1transit.proc,
                     G1transit.ddl,
                     model.parameters = list(Phi = phi.age, p = p))
cjsage.G1transit$results$real
```

Autre façon. 
```{r}
G1transit.ddl <- make.design.data(G1transit.proc)
#max age 4
G1transit.ddl$Phi$max.age <- as.factor((G1transit.ddl$Phi$Age < 1) * G1transit.ddl$Phi$Age + (G1transit.ddl$Phi$Age>0) * 1)
phi.max.age <- list(formula=~max.age)
cjsaget.G1transit <- mark(G1transit.proc,
                     G1transit.ddl,
                     model.parameters = list(Phi = phi.max.age, p = p))

PIMS(cjsaget.G1transit,"Phi")
cjsaget.G1transit$results$real
```

Supprime fichiers créés en cours de route.
```{r}
cleanup(ask = FALSE)
```

