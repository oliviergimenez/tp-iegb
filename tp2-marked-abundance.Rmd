---
title: "TP 2 marked abundance"
author: "Olivier Gimenez"
date: "19/12/2020"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE)
```

On charge le package `RMark`.
```{r}
library(RMark)
```

Et aussi le tidyverse.
```{r}
library(tidyverse)
```


# Partie 1 : le cours

Les données.
```{r}
capsid <- convert.inp("dat/capsid.inp",
                    group.df = NULL,
                    covariates = NULL)
head(capsid)
tail(capsid)
```

On charge le package `secr` qui permet d'implémenter le test de `closure`.
```{r}
library(secr)
```

On met les données au format adéquat.
```{r}
capsid_secr <- unRMarkInput(capsid)
```

On explore le jeu de données.
```{r}
summary(capsid_secr)
```

On fait les tests de Stanley et Burnham et de Otis. 
```{r}
test <- closure.test(capsid_secr, SB = TRUE)
```

Pour Otis, on a :
```{r}
test$Otis
```

Pour Stanley-Burnham, on a :
```{r}
test$Xc
```

Les composantes de Stanley-Burnham :
```{r}
test$NRvsJS
test$MtvsNM
test$MtvsNR
test$NRvsJS
```

Les sous-composantes de NR vs JS.
```{r}
round(test$compNRvsJS, 2)
```

Les sous-composantes de NM vs JS.
```{r}
round(test$compNMvsJS, 2)
```

On supprime les 3 premières et dernières occasions. On sépare d'abord les colonnes, on sélectionne les colonnes 4 à 10, on supprime les lignes de 0, puis on les recolle et on reconvertit au format requis. 
```{r}
capsid_reduced <- capsid
ch <- splitCH(capsid_reduced$ch) # sépare colonnes
head(ch)
ch_reduced <- ch[, 4:10] # sélection colonnes 4 à 10
head(ch_reduced)
dim(ch_reduced)
mask <- apply(ch_reduced, 1, sum)
ch_reduced <- ch_reduced[mask > 0,] # supprime lignes de 0
head(ch_reduced)
dim(ch_reduced)
freq_reduced <- capsid_reduced$freq[mask > 0]
length(freq_reduced)
capsid_reduced <- data.frame(ch = collapseCH(ch_reduced), # on recolle les colonnes ensemble
                             freq = freq_reduced)
capsid_reduced_secr <- unRMarkInput(capsid_reduced) # on convertit au bon format
```

Jette un coup d'oeil.
```{r}
summary(capsid_reduced_secr)
```

On refait les tests de Stanley et Burnham et de Otis. 
```{r}
closure.test(capsid_reduced_secr, SB = TRUE)
```

Ca change pas grand chose. Est-ce le bon fichier capsid.inp?!

# Partie 2 : mouse deer

Les données
```{r}
mouse <- convert.inp("dat/deer-mouse-nogroup.inp",
                    group.df = NULL,
                    covariates = NULL)
head(mouse)
tail(mouse)
```

On fait les tests de fermeture.
```{r}
mouse_secr <- unRMarkInput(mouse) # on convertit au bon format
summary(mouse_secr) # resumes
closure.test(mouse_secr, SB = TRUE)
```

Process data
```{r}
mouse.proc <- process.data(mouse, begin.time = 1, model = "FullHet")
```

Create default design data
```{r}
mouse.ddl <- make.design.data(mouse.proc)
```

Here, we set up the structures for 'p' and 'c'. I use the "share = TRUE" or "share = FALSE" options in each of the structures to indicate whether 'p' & 'c' should share the same columns of the design matrix or not. Although this is not necessary for all of the structures below, it does add a covariate "c" to the design data with c=0 for rows pertaining to parameter 'p' and c=1 for rows pertaining to parameter 'c. This is nice as it gives us the opportunity to build some of the additive structures we're interested in. We can then use the covariate "c" in formula statements if we want to. But, we don't have to include that covariate if we don't want to (e.g., see the p.dot structure).

```{r}
run.mouse <- function() {

  p.dot <- list(formula =  ~ 1, share = TRUE)
  p.dot.behav <- list(formula =  ~ 1, share = FALSE)
  p.time <- list(formula =  ~ time, share = TRUE)
  p.time.behav <- list(formula =  ~ time, share = FALSE)
  p.h <- list(formula = ~ mixture, share = TRUE)
  p.h.behav <- list(formula = ~ mixture, share = FALSE)
  p.h.time <- list(formula = ~ time + mixture, share = TRUE)
  p.h.time.behav <- list(formula = ~ time + mixture, share = FALSE)

  mouse.model.list <- create.model.list("FullHet")
  
  mouse.results <- mark.wrapper(mouse.model.list,
                              data = mouse.proc, 
                              ddl = mouse.ddl)
                              
  return(mouse.results)
}
```

Run the models and examine the output
```{r}
mouse.results <- run.mouse()
```

Examine model-selection table
```{r}
mouse.results
```

examine model names and find the name of the top model
```{r}
names(mouse.results)
```

examine the output from top-ranked model (#5)
```{r}
mouse.results$p.h.time$results$real
mouse.results$p.h.time$results$derived
```

Comme dans les diapos.
```{r}
mouse.results$p.dot.behav$results$real
mouse.results$p.dot.behav$results$derived
```

La même chose avec le sexe maintenant. 


Les données
```{r}
mouse <- convert.inp("dat/deer-mouse-sex2G-MF.inp",
                    group.df = data.frame(sex = c("M","F")),
                    covariates = NULL)
head(mouse)
tail(mouse)
```

On sépare mâles et femelles.
```{r}
mouseM <- mouse[mouse$sex == "M", ]
mouseF <- mouse[mouse$sex == "F", ]
```

On formate les données. 
```{r}
mouseM_secr <- unRMarkInput(mouseM) # on convertit au bon format
mouseF_secr <- unRMarkInput(mouseF) # on convertit au bon format
summary(mouseM_secr) # resumes
summary(mouseF_secr) # resumes
```


On fait les tests de fermeture, mâles d'abord. 
```{r}
closure.test(mouseM_secr, SB = TRUE)
```

Femelles ensuite 
```{r}
closure.test(mouseF_secr, SB = TRUE)
```

Les modèles maintenant. 

Process data
```{r}
mouse.proc <- process.data(mouse, begin.time = 1, model = "FullHet", groups = "sex")
```

Create default design data
```{r}
mouse.ddl <- make.design.data(mouse.proc)
```

Liste des modèles.
```{r}
run.mouse <- function() {

  p.dot <- list(formula =  ~ 1, share = TRUE)
  p.dot.behav <- list(formula =  ~ 1, share = FALSE)
  p.time <- list(formula =  ~ time, share = TRUE)
  p.time.behav <- list(formula =  ~ time, share = FALSE)
  p.h <- list(formula = ~ mixture, share = TRUE)
  p.h.behav <- list(formula = ~ mixture, share = FALSE)
  p.h.time <- list(formula = ~ time + mixture, share = TRUE)
  p.h.time.behav <- list(formula = ~ time + mixture, share = FALSE)
  p.sex <- list(formula =  ~ sex, share = TRUE)
  p.sex.behav <- list(formula =  ~ sex, share = FALSE)
  p.time.sex <- list(formula =  ~ time + sex, share = TRUE)
  p.time.behav.sex <- list(formula =  ~ time + sex, share = FALSE)
  p.h.sex <- list(formula = ~ mixture + sex, share = TRUE)
  p.h.behav.sex <- list(formula = ~ mixture + sex, share = FALSE)
  p.h.time.sex <- list(formula = ~ time + mixture + sex, share = TRUE)
  p.h.time.behav.sex <- list(formula = ~ time + mixture + sex, share = FALSE)

  mouse.model.list <- create.model.list("FullHet")
  
  mouse.results <- mark.wrapper(mouse.model.list,
                              data = mouse.proc, 
                              ddl = mouse.ddl)
                              
  return(mouse.results)
}
```

Run the models and examine the output
```{r}
mouse.results <- run.mouse()
```

Examine model-selection table
```{r}
mouse.results
```

examine model names and find the name of the top model
```{r}
names(mouse.results)
```

examine the output from top-ranked model (#10)
```{r}
mouse.results$p.h.time.sex$results$real
mouse.results$p.h.time.sex$results$derived
```

Comme dans les diapos.
```{r}
mouse.results$p.dot.behav$results$real
mouse.results$p.dot.behav$results$derived
```

La même chose avec l'âge maintenant. 


Les données
```{r}
mouse <- convert.inp("dat/deer-mouse-age-3G-Y-SA-A.inp",
                    group.df = data.frame(ages = c("Y","SA", "A")),
                    covariates = NULL)
head(mouse)
tail(mouse)
```

On sépare mâles et femelles.
```{r}
mouseY <- mouse[mouse$ages == "Y", ]
mouseSA <- mouse[mouse$ages == "SA", ]
mouseA <- mouse[mouse$ages == "A", ]
```

On formate les données. 
```{r}
mouseY_secr <- unRMarkInput(mouseY) # on convertit au bon format
mouseSA_secr <- unRMarkInput(mouseSA) # on convertit au bon format
mouseA_secr <- unRMarkInput(mouseA) # on convertit au bon format
```


On fait les tests de fermeture, Y d'abord. 
```{r}
closure.test(mouseY_secr, SB = TRUE)
```

SA ensuite.
```{r}
closure.test(mouseSA_secr, SB = TRUE)
```

A enfin
```{r}
closure.test(mouseA_secr, SB = TRUE)
```

Les modèles maintenant. 

Process data
```{r}
mouse.proc <- process.data(mouse, begin.time = 1, model = "FullHet", groups = "ages")
```

Create default design data
```{r}
mouse.ddl <- make.design.data(mouse.proc)
```

Liste des modèles.
```{r}
run.mouse <- function() {

  p.dot <- list(formula =  ~ 1, share = TRUE)
  p.dot.behav <- list(formula =  ~ 1, share = FALSE)
  p.time <- list(formula =  ~ time, share = TRUE)
  p.time.behav <- list(formula =  ~ time, share = FALSE)
  p.h <- list(formula = ~ mixture, share = TRUE)
  p.h.behav <- list(formula = ~ mixture, share = FALSE)
  p.h.time <- list(formula = ~ time + mixture, share = TRUE)
  p.h.time.behav <- list(formula = ~ time + mixture, share = FALSE)
  p.age <- list(formula =  ~ ages, share = TRUE)
  p.age.behav <- list(formula =  ~ ages, share = FALSE)
  p.time.age <- list(formula =  ~ time + ages, share = TRUE)
  p.time.behav.age <- list(formula =  ~ time + ages, share = FALSE)
  p.h.age <- list(formula = ~ mixture + ages, share = TRUE)
  p.h.behav.age <- list(formula = ~ mixture + ages, share = FALSE)
  p.h.time.age <- list(formula = ~ time + mixture + ages, share = TRUE)
  p.h.time.behav.age <- list(formula = ~ time + mixture + ages, share = FALSE)

  mouse.model.list <- create.model.list("FullHet")
  
  mouse.results <- mark.wrapper(mouse.model.list,
                              data = mouse.proc, 
                              ddl = mouse.ddl)
                              
  return(mouse.results)
}
```

Run the models and examine the output
```{r}
mouse.results <- run.mouse()
```

Examine model-selection table
```{r}
mouse.results
```

examine model names and find the name of the top model
```{r}
names(mouse.results)
```

examine the output from top-ranked model (#5)
```{r}
mouse.results$p.h.time$results$real
mouse.results$p.h.time$results$derived
```

# Partie 3 : cigognes

On passe aux cigognes. 

Les données
```{r}
cigogne <- convert.inp("dat/cigognes-2002-3G.inp",
                    group.df = data.frame(bagues = c("metal","couleur", "darvic")),
                    covariates = NULL)
head(cigogne)
tail(cigogne)
```

On formate les données. 
```{r}
cigogne_secr <- unRMarkInput(cigogne) # on convertit au bon format
```


On fait les tests de fermeture. 
```{r}
closure.test(cigogne_secr, SB = TRUE)
```

Les modèles maintenant. On sépare selon le type de bagues.

Couleur d'abord
```{r}
cigogne_bague <- cigogne[cigogne$bagues=="couleur",]
cigogne.proc <- process.data(cigogne_bague, begin.time = 1, model = "FullHet")
cigogne.ddl <- make.design.data(cigogne.proc)
```

Liste des modèles.
```{r}
run.cigogne <- function() {

  p.dot <- list(formula =  ~ 1, share = TRUE)
  p.time <- list(formula =  ~ time, share = TRUE)
  p.h <- list(formula = ~ mixture, share = TRUE)
  p.h.time <- list(formula = ~ time + mixture, share = TRUE)
  cigogne.model.list <- create.model.list("FullHet")
  cigogne.results <- mark.wrapper(cigogne.model.list,
                                  data = cigogne.proc, 
                                  ddl = cigogne.ddl)
  return(cigogne.results)
}
```

Run the models and examine the output
```{r}
cigogne.results <- run.cigogne()
```

Examine model-selection table
```{r}
cigogne.results
```

examine model names and find the name of the top model
```{r}
names(cigogne.results)
```

examine the output from top-ranked models
```{r}
(pcouleur <- cigogne.results$p.time$results$real)
(Ncouleur <- cigogne.results$p.time$results$derived)
```

Darvic ensuite.
```{r}
cigogne_bague <- cigogne[cigogne$bagues=="darvic",]
cigogne.proc <- process.data(cigogne_bague, begin.time = 1, model = "FullHet")
cigogne.ddl <- make.design.data(cigogne.proc)
```

Run the models and examine the output
```{r}
cigogne.results <- run.cigogne()
```

Examine model-selection table
```{r}
cigogne.results
```

examine model names and find the name of the top model
```{r}
names(cigogne.results)
```

examine the output from top-ranked models
```{r}
(pdarvic <- cigogne.results$p.h.time$results$real)
(Ndarvic <- cigogne.results$p.h.time$results$derived)
```

Metal enfin.
```{r}
cigogne_bague <- cigogne[cigogne$bagues=="metal",]
cigogne.proc <- process.data(cigogne_bague, begin.time = 1, model = "FullHet")
cigogne.ddl <- make.design.data(cigogne.proc)
```

Run the models and examine the output
```{r}
cigogne.results <- run.cigogne()
```

Examine model-selection table
```{r}
cigogne.results
```

examine model names and find the name of the top model
```{r}
names(cigogne.results)
```

examine the output from top-ranked models
```{r}
(pmetal <- cigogne.results$p.time$results$real)
(Nmetal <- cigogne.results$p.time$results$derived)
```

Visualise les prob de détection.
```{r}
p.estim <- data.frame(couleur = pcouleur[-c(1,16),1],
                      darvic = pdarvic[-c(1,30),1], 
                      metal = pmetal[-c(1,16),1],
                      mixture = c(rep("M1", 14), rep("M2", 14)),
                      occ = c(1:14, 1:14))
p.estim <- tidyr::pivot_longer(p.estim, 
                               cols = couleur:metal,
                               names_to = "type_bague", 
                               values_to = "p_estim")
ggplot(data = p.estim,
       aes(x = occ, y = p_estim, color = mixture)) +
  geom_line() +
  facet_wrap(~type_bague) + 
  theme_light() +
  labs(x = "occasions de capture",
       y = "probabilité estimée de capture",
       color = "classe hétérogénéité")
```

# Partie 4 : cistudes

On passe à l'exercice sur les cistudes.

Les données
```{r}
dat <- read_csv2("dat/BDD-CMR-Cistudes-Vigueirat.csv")
dat <- janitor::clean_names(dat)
```

Quelles sont les années avec le plus de marquages et recaptures?
```{r}
dat %>% 
  count(action, mois, annee, sort = TRUE)
dat <- dat %>% select(id_ind, jour, mois, annee)
```

On extrait les mois de juin des années 1997 et 2007.
```{r}
dat1997 <- dat %>% 
  filter(mois == 6, annee == 1997) %>% 
  select(id_ind, jour) %>% 
  add_column(det = 1) %>% 
  arrange(id_ind)
dat2007 <- dat %>% 
  filter(mois == 6, annee == 2007) %>% 
  select(id_ind, jour) %>% 
  add_column(det = 1) %>% 
  arrange(id_ind)
```

On fait les histoires pour 1997.
```{r}
histories1997 <- dat1997 %>% 
  group_by(id_ind) %>%
  mutate(id2 = row_number()) %>%
  pivot_wider(values_from = det,
              names_from = jour) %>% # les jours en colonnes
  select(-id2) %>%
  group_by(id_ind) %>%
  summarise(across(everything(), sum, na.rm = TRUE)) %>% # on rassemble les evenements pour chaque ind
  select(-id_ind)
histories1997[is.na(histories1997)] <- 0 # les Na sont des non-détections = 0   
histories1997[histories1997 > 1] <- 1 # les observations mens multiples = 1
(histories1997 <- as.matrix(histories1997))
```

Et pour 2007.
```{r}
histories2007 <- dat2007 %>% 
  group_by(id_ind) %>%
  mutate(id2 = row_number()) %>%
  pivot_wider(values_from = det,
              names_from = jour) %>% # les jours en colonnes
  select(-id2) %>%
  group_by(id_ind) %>%
  summarise(across(everything(), sum, na.rm = TRUE)) %>% # on rassemble les evenements pour chaque ind
  select(-id_ind)
histories2007[is.na(histories2007)] <- 0 # les Na sont des non-détections = 0   
histories2007[histories2007 > 1] <- 1 # les observations mens multiples = 1
(histories2007 <- as.matrix(histories2007))
```

On fait les tests et l'ajustement pour 1997.
```{r}
cistude <- data.frame(ch = collapseCH(histories1997), freq = rep(1, nrow(histories1997)))
head(cistude)
tail(cistude)
```

On fait les tests de fermeture.
```{r}
cistude_secr <- unRMarkInput(cistude) # on convertit au bon format
summary(cistude_secr) # resumes
closure.test(cistude_secr, SB = TRUE)
```

Process data
```{r}
cistude.proc <- process.data(cistude, begin.time = 1, model = "FullHet")
```

Create default design data
```{r}
cistude.ddl <- make.design.data(cistude.proc)
```

```{r}
run.cistude <- function() {

  p.dot <- list(formula =  ~ 1, share = TRUE)
  p.dot.behav <- list(formula =  ~ 1, share = FALSE)
  p.time <- list(formula =  ~ time, share = TRUE)
  p.time.behav <- list(formula =  ~ time, share = FALSE)
  p.h <- list(formula = ~ mixture, share = TRUE)
  p.h.behav <- list(formula = ~ mixture, share = FALSE)
  p.h.time <- list(formula = ~ time + mixture, share = TRUE)
  p.h.time.behav <- list(formula = ~ time + mixture, share = FALSE)

  cistude.model.list <- create.model.list("FullHet")
  
  cistude.results <- mark.wrapper(cistude.model.list,
                              data = cistude.proc, 
                              ddl = cistude.ddl)
                              
  return(cistude.results)
}
```

Run the models and examine the output
```{r}
cistude.results <- run.cistude()
```

Examine model-selection table
```{r}
cistude.results
```

examine model names and find the name of the top model
```{r}
names(cistude.results)
```

examine the output from top-ranked model (#5)
```{r}
cistude.results$p.dot$results$real
cistude.results$p.dot$results$derived
```

Idem avec 2007.

```{r}
cistude <- data.frame(ch = collapseCH(histories2007), freq = rep(1, nrow(histories2007)))
head(cistude)
tail(cistude)
```

On fait les tests de fermeture.
```{r}
cistude_secr <- unRMarkInput(cistude) # on convertit au bon format
summary(cistude_secr) # resumes
closure.test(cistude_secr, SB = TRUE)
```

Process data
```{r}
cistude.proc <- process.data(cistude, begin.time = 1, model = "FullHet")
```

Create default design data
```{r}
cistude.ddl <- make.design.data(cistude.proc)
```

```{r}
run.cistude <- function() {

  p.dot <- list(formula =  ~ 1, share = TRUE)
  p.dot.behav <- list(formula =  ~ 1, share = FALSE)
  p.time <- list(formula =  ~ time, share = TRUE)
  p.time.behav <- list(formula =  ~ time, share = FALSE)
  p.h <- list(formula = ~ mixture, share = TRUE)
  p.h.behav <- list(formula = ~ mixture, share = FALSE)
  p.h.time <- list(formula = ~ time + mixture, share = TRUE)
  p.h.time.behav <- list(formula = ~ time + mixture, share = FALSE)

  cistude.model.list <- create.model.list("FullHet")
  
  cistude.results <- mark.wrapper(cistude.model.list,
                              data = cistude.proc, 
                              ddl = cistude.ddl)
                              
  return(cistude.results)
}
```

Run the models and examine the output
```{r}
cistude.results <- run.cistude()
```

Examine model-selection table
```{r}
cistude.results
```

examine model names and find the name of the top model
```{r}
names(cistude.results)
```

examine the output from top-ranked model (#5)
```{r}
cistude.results$p.dot$results$real
cistude.results$p.dot$results$derived
```

# Partie 5 : monarques

On passe à l'analyse des données monarques.

Les données.
```{r}
dat <- readxl::read_xlsx("dat/CMR-Monarque-2019.xlsx") %>%
  janitor::clean_names() %>%
  select(session, identifiant) %>%
  filter(identifiant != 0) %>%
  add_column(det = 1) %>%
  arrange(identifiant)
dat
```

On construit les histoire de capture.
```{r}
histoires <- dat %>% 
  group_by(identifiant) %>%
  mutate(id2 = row_number()) %>%
  pivot_wider(values_from = det,
              names_from = session) %>% # les jours en colonnes
  select(-id2) %>%
  group_by(identifiant) %>%
  summarise(across(everything(), sum, na.rm = TRUE)) %>% # on rassemble les evenements pour chaque ind
  select(-identifiant)
histoires[is.na(histoires)] <- 0 # les Na sont des non-détections = 0   
histoires[histoires > 1] <- 1 # les observations mens multiples = 1
(histoires <- as.matrix(histoires))
```

On fait les tests et l'ajustement.
```{r}
monarque <- data.frame(ch = collapseCH(histoires), freq = rep(1, nrow(histoires)))
head(monarque)
tail(monarque)
```

On fait les tests de fermeture.
```{r}
monarque_secr <- unRMarkInput(monarque) # on convertit au bon format
summary(monarque_secr) # resumes
closure.test(monarque_secr, SB = TRUE)
```

On sélectionne les occasions 2 à 5. 
```{r}
monarque_reduced <- monarque
ch <- splitCH(monarque_reduced$ch) # sépare colonnes
head(ch)
ch_reduced <- ch[, 2:5] # sélection colonnes 2 à 5
head(ch_reduced)
dim(ch_reduced)
mask <- apply(ch_reduced, 1, sum)
ch_reduced <- ch_reduced[mask > 0,] # supprime lignes de 0
head(ch_reduced)
dim(ch_reduced)
freq_reduced <- monarque_reduced$freq[mask > 0]
length(freq_reduced)
monarque_reduced <- data.frame(ch = collapseCH(ch_reduced), # on recolle les colonnes ensemble
                             freq = freq_reduced)
monarque_reduced_secr <- unRMarkInput(monarque_reduced) # on convertit au bon format
```

Jette un coup d'oeil.
```{r}
summary(monarque_reduced_secr)
```

On refait les tests de Stanley et Burnham et de Otis. 
```{r}
closure.test(monarque_reduced_secr, SB = TRUE)
```

On passe aux analyses.
```{r}
monarque.proc <- process.data(monarque_reduced, begin.time = 1, model = "FullHet")
```

Create default design data
```{r}
monarque.ddl <- make.design.data(monarque.proc)
```

```{r}
run.monarque <- function() {

  p.dot <- list(formula =  ~ 1, share = TRUE)
  p.dot.behav <- list(formula =  ~ 1, share = FALSE)
  p.time <- list(formula =  ~ time, share = TRUE)
  p.time.behav <- list(formula =  ~ time, share = FALSE)
  p.h <- list(formula = ~ mixture, share = TRUE)
  p.h.behav <- list(formula = ~ mixture, share = FALSE)
  p.h.time <- list(formula = ~ time + mixture, share = TRUE)
  p.h.time.behav <- list(formula = ~ time + mixture, share = FALSE)

  monarque.model.list <- create.model.list("FullHet")
  
  monarque.results <- mark.wrapper(monarque.model.list,
                              data = monarque.proc, 
                              ddl = monarque.ddl)
                              
  return(monarque.results)
}
```

Run the models and examine the output
```{r}
monarque.results <- run.monarque()
```

Examine model-selection table
```{r}
monarque.results
```

examine model names and find the name of the top model
```{r}
names(monarque.results)
```

examine the output from top-ranked model (#8)
```{r}
monarque.results$p.time.behav$results$real
monarque.results$p.time.behav$results$derived
```

Autre modèle.
```{r}
monarque.results$p.h.time.behav$results$real
monarque.results$p.h.time.behav$results$derived
```

Autre modèle.
```{r}
monarque.results$p.time$results$real
monarque.results$p.time$results$derived
```

Modèle des diapos
```{r}
monarque.results$p.h.time$results$real
monarque.results$p.h.time$results$derived
```

# Partie 6 : iguanes

## Données 2006

Les données
```{r}
iguane <- convert.inp("dat/iguanes-2006-2sexes-FM.inp",
                    group.df = data.frame(sex = c("F","M")),
                    covariates = NULL)
head(iguane)
tail(iguane)
```

On sépare mâles et femelles.
```{r}
iguaneM <- iguane[iguane$sex == "M", ]
iguaneF <- iguane[iguane$sex == "F", ]
```

On formate les données. 
```{r}
iguane_secr <- unRMarkInput(iguane) # on convertit au bon format
iguaneM_secr <- unRMarkInput(iguaneM) # on convertit au bon format
iguaneF_secr <- unRMarkInput(iguaneF) # on convertit au bon format
summary(iguane_secr) # resumes
summary(iguaneM_secr) # resumes
summary(iguaneF_secr) # resumes
```


Les deux sexes ensemble.
```{r}
closure.test(iguane_secr, SB = TRUE)
```

On fait les tests de fermeture, mâles d'abord. 
```{r}
closure.test(iguaneM_secr, SB = TRUE)
```

Femelles ensuite 
```{r}
closure.test(iguaneF_secr, SB = TRUE)
```

Les modèles maintenant. On commence par le jeu de données avec les deux sexes ensemble.

Process data
```{r}
iguane.proc <- process.data(iguane, begin.time = 1, model = "FullHet")
```

Create default design data
```{r}
iguane.ddl <- make.design.data(iguane.proc)
```

Liste des modèles.
```{r}
run.iguane <- function() {

  p.dot <- list(formula =  ~ 1, share = TRUE)
  p.dot.behav <- list(formula =  ~ 1, share = FALSE)
  p.time <- list(formula =  ~ time, share = TRUE)
  p.time.behav <- list(formula =  ~ time, share = FALSE)
  p.h <- list(formula = ~ mixture, share = TRUE)
  p.h.behav <- list(formula = ~ mixture, share = FALSE)
  p.h.time <- list(formula = ~ time + mixture, share = TRUE)
  p.h.time.behav <- list(formula = ~ time + mixture, share = FALSE)

  iguane.model.list <- create.model.list("FullHet")
  
  iguane.results <- mark.wrapper(iguane.model.list,
                              data = iguane.proc, 
                              ddl = iguane.ddl)
                              
  return(iguane.results)
}
```

Run the models and examine the output
```{r}
iguane.results <- run.iguane()
```

Examine model-selection table
```{r}
iguane.results
```

examine model names and find the name of the top model
```{r}
names(iguane.results)
```

examine the output from top-ranked model (#8)
```{r}
iguane.results$p.time.behav$results$real
iguane.results$p.time.behav$results$derived
```

En séparant les sexes. Femelles, puis mâles. 

Process data
```{r}
iguane.proc <- process.data(iguaneF, begin.time = 1, model = "FullHet")
```

Create default design data
```{r}
iguane.ddl <- make.design.data(iguane.proc)
```

Liste des modèles.
```{r}
run.iguane <- function() {

  p.dot <- list(formula =  ~ 1, share = TRUE)
  p.dot.behav <- list(formula =  ~ 1, share = FALSE)
  p.time <- list(formula =  ~ time, share = TRUE)
  p.time.behav <- list(formula =  ~ time, share = FALSE)
  p.h <- list(formula = ~ mixture, share = TRUE)
  p.h.behav <- list(formula = ~ mixture, share = FALSE)
  p.h.time <- list(formula = ~ time + mixture, share = TRUE)
  p.h.time.behav <- list(formula = ~ time + mixture, share = FALSE)

  iguane.model.list <- create.model.list("FullHet")
  
  iguane.results <- mark.wrapper(iguane.model.list,
                              data = iguane.proc, 
                              ddl = iguane.ddl)
                              
  return(iguane.results)
}
```

Run the models and examine the output
```{r}
iguane.results <- run.iguane()
```

Examine model-selection table
```{r}
iguane.results
```

examine model names and find the name of the top model
```{r}
names(iguane.results)
```

examine the output from top-ranked model (#8)
```{r}
iguane.results$p.time.behav$results$real
iguane.results$p.time.behav$results$derived
```


Process data
```{r}
iguane.proc <- process.data(iguaneM, begin.time = 1, model = "FullHet")
```

Create default design data
```{r}
iguane.ddl <- make.design.data(iguane.proc)
```

Liste des modèles.
```{r}
run.iguane <- function() {

  p.dot <- list(formula =  ~ 1, share = TRUE)
  p.dot.behav <- list(formula =  ~ 1, share = FALSE)
  p.time <- list(formula =  ~ time, share = TRUE)
  p.time.behav <- list(formula =  ~ time, share = FALSE)
  p.h <- list(formula = ~ mixture, share = TRUE)
  p.h.behav <- list(formula = ~ mixture, share = FALSE)
  p.h.time <- list(formula = ~ time + mixture, share = TRUE)
  p.h.time.behav <- list(formula = ~ time + mixture, share = FALSE)

  iguane.model.list <- create.model.list("FullHet")
  
  iguane.results <- mark.wrapper(iguane.model.list,
                              data = iguane.proc, 
                              ddl = iguane.ddl)
                              
  return(iguane.results)
}
```

Run the models and examine the output
```{r}
iguane.results <- run.iguane()
```

Examine model-selection table
```{r}
iguane.results
```

examine model names and find the name of the top model
```{r}
names(iguane.results)
```

examine the output from top-ranked model (#8)
```{r}
iguane.results$p.time.behav$results$real
iguane.results$p.time.behav$results$derived
```


## Données 2010

Les données
```{r}
iguane <- convert.inp("dat/iguanes-2010-2sexes-FM.inp",
                    group.df = data.frame(sex = c("F","M")),
                    covariates = NULL)
head(iguane)
tail(iguane)
```

On sépare mâles et femelles.
```{r}
iguaneM <- iguane[iguane$sex == "M", ]
iguaneF <- iguane[iguane$sex == "F", ]
```

On formate les données. 
```{r}
iguane_secr <- unRMarkInput(iguane) # on convertit au bon format
summary(iguane_secr) # resumes
```

Les deux sexes ensemble.
```{r}
closure.test(iguane_secr, SB = TRUE)
```

Les modèles maintenant. On commence par le jeu de données avec les deux sexes ensemble.

Process data
```{r}
iguane.proc <- process.data(iguane, begin.time = 1, model = "FullHet")
```

Create default design data
```{r}
iguane.ddl <- make.design.data(iguane.proc)
```

Liste des modèles.
```{r}
run.iguane <- function() {

  p.dot <- list(formula =  ~ 1, share = TRUE)
  p.dot.behav <- list(formula =  ~ 1, share = FALSE)
  p.time <- list(formula =  ~ time, share = TRUE)
  p.time.behav <- list(formula =  ~ time, share = FALSE)
  p.h <- list(formula = ~ mixture, share = TRUE)
  p.h.behav <- list(formula = ~ mixture, share = FALSE)
  p.h.time <- list(formula = ~ time + mixture, share = TRUE)
  p.h.time.behav <- list(formula = ~ time + mixture, share = FALSE)

  iguane.model.list <- create.model.list("FullHet")
  
  iguane.results <- mark.wrapper(iguane.model.list,
                              data = iguane.proc, 
                              ddl = iguane.ddl)
                              
  return(iguane.results)
}
```

Run the models and examine the output
```{r}
iguane.results <- run.iguane()
```

Examine model-selection table
```{r}
iguane.results
```

examine model names and find the name of the top model
```{r}
names(iguane.results)
```

examine the output from top-ranked model (#8)
```{r}
iguane.results$p.dot$results$real
iguane.results$p.dot$results$derived
```

En séparant les sexes. Femelles, puis mâles. 

Process data
```{r}
iguane.proc <- process.data(iguaneF, begin.time = 1, model = "FullHet")
```

Create default design data
```{r}
iguane.ddl <- make.design.data(iguane.proc)
```

Liste des modèles.
```{r}
run.iguane <- function() {

  p.dot <- list(formula =  ~ 1, share = TRUE)
  p.dot.behav <- list(formula =  ~ 1, share = FALSE)
  p.time <- list(formula =  ~ time, share = TRUE)
  p.time.behav <- list(formula =  ~ time, share = FALSE)
  p.h <- list(formula = ~ mixture, share = TRUE)
  p.h.behav <- list(formula = ~ mixture, share = FALSE)
  p.h.time <- list(formula = ~ time + mixture, share = TRUE)
  p.h.time.behav <- list(formula = ~ time + mixture, share = FALSE)

  iguane.model.list <- create.model.list("FullHet")
  
  iguane.results <- mark.wrapper(iguane.model.list,
                              data = iguane.proc, 
                              ddl = iguane.ddl)
                              
  return(iguane.results)
}
```

Run the models and examine the output
```{r}
iguane.results <- run.iguane()
```

Examine model-selection table
```{r}
iguane.results
```

examine model names and find the name of the top model
```{r}
names(iguane.results)
```

examine the output from top-ranked model (#8)
```{r}
iguane.results$p.dot$results$real
iguane.results$p.dot$results$derived
```


Process data
```{r}
iguane.proc <- process.data(iguaneM, begin.time = 1, model = "FullHet")
```

Create default design data
```{r}
iguane.ddl <- make.design.data(iguane.proc)
```

Liste des modèles.
```{r}
run.iguane <- function() {

  p.dot <- list(formula =  ~ 1, share = TRUE)
  p.dot.behav <- list(formula =  ~ 1, share = FALSE)
  p.time <- list(formula =  ~ time, share = TRUE)
  p.time.behav <- list(formula =  ~ time, share = FALSE)
  p.h <- list(formula = ~ mixture, share = TRUE)
  p.h.behav <- list(formula = ~ mixture, share = FALSE)
  p.h.time <- list(formula = ~ time + mixture, share = TRUE)
  p.h.time.behav <- list(formula = ~ time + mixture, share = FALSE)

  iguane.model.list <- create.model.list("FullHet")
  
  iguane.results <- mark.wrapper(iguane.model.list,
                              data = iguane.proc, 
                              ddl = iguane.ddl)
                              
  return(iguane.results)
}
```

Run the models and examine the output
```{r}
iguane.results <- run.iguane()
```

Examine model-selection table
```{r}
iguane.results
```

examine model names and find the name of the top model
```{r}
names(iguane.results)
```

examine the output from top-ranked model (#8)
```{r}
iguane.results$p.dot$results$real
iguane.results$p.dot$results$derived
```


# Nettoyage

On supprime les fichiers temporaires. 

```{r}
rm(list = ls(all = TRUE))
cleanup(ask = FALSE)
```

